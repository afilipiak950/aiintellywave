
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/integrations/supabase/client';
import { SearchStringType, SearchStringSource } from './search-string-types';
import { v4 as uuidv4 } from 'uuid';

interface UseSearchStringOperationsProps {
  user: any;
  fetchSearchStrings: () => Promise<void>;
}

export const useSearchStringOperations = ({ user, fetchSearchStrings }: UseSearchStringOperationsProps) => {
  const { toast } = useToast();

  const generatePreview = async (
    type: SearchStringType,
    inputSource: SearchStringSource,
    inputText?: string,
    inputUrl?: string,
    pdfFile?: File | null
  ): Promise<string> => {
    try {
      let prompt = '';
      
      if (inputSource === 'text' && inputText) {
        const keywords = inputText.split(/\s+/).filter(word => word.length > 3).slice(0, 5);
        prompt = `(${keywords.join(' OR ')}) AND "${type === 'recruiting' ? 'resume' : 'business'}"`;
      } else if (inputSource === 'website' && inputUrl) {
        try {
          const domain = new URL(inputUrl).hostname.replace('www.', '');
          
          if (type === 'recruiting') {
            prompt = `Website crawler is analyzing ${domain}...\n\nCurrently extracting job posting details, this may take a few moments.\n\nThe search string will be generated by analyzing the ACTUAL content of the job description including required skills, experience levels, job title, and location information.\n\nSubmit to generate a complete Boolean search string based on the website content.`;
          } else {
            prompt = `Website crawler is analyzing ${domain}...\n\nCurrently extracting company information, this may take a few moments.\n\nThe search string will be generated by analyzing the ACTUAL content of the business website including services, industry, locations, and company details.\n\nSubmit to generate a complete Boolean search string based on the website content.`;
          }
        } catch (error) {
          console.error('Invalid URL format:', error);
          prompt = `Invalid URL format. Please enter a valid URL.`;
        }
      } else if (inputSource === 'pdf' && pdfFile) {
        prompt = `Analyzing PDF: ${pdfFile.name}... The search string will be generated based on all content extracted from the document.`;
      }
      
      return prompt;
    } catch (error) {
      console.error('Error generating preview:', error);
      throw new Error('Failed to generate preview');
    }
  };

  const processSearchStringBySource = async (
    searchString: any,
    inputSource: SearchStringSource,
    type: SearchStringType,
    inputText?: string,
    inputUrl?: string,
    pdfFile?: File | null
  ) => {
    if (inputSource === 'pdf' && pdfFile) {
      const filePath = `search-strings/${searchString.user_id}/${searchString.id}/${pdfFile.name}`;
      
      const { error: uploadError } = await supabase.storage
        .from('uploads')
        .upload(filePath, pdfFile);
      
      if (uploadError) {
        console.error('Error uploading PDF:', uploadError);
        throw uploadError;
      }
      
      const { error: updateError } = await supabase
        .from('search_strings')
        .update({ 
          input_pdf_path: filePath, 
          status: 'processing' 
        })
        .eq('id', searchString.id);
      
      if (updateError) {
        console.error('Error updating search string with PDF path:', updateError);
        throw updateError;
      }
      
      try {
        const { error: functionError } = await supabase.functions
          .invoke('process-pdf', { 
            body: { 
              search_string_id: searchString.id,
              pdf_path: filePath
            }
          });
        
        if (functionError) {
          console.error('Error calling process-pdf function:', functionError);
        }
      } catch (functionErr) {
        console.error('Error calling process-pdf function:', functionErr);
      }
    } else {
      const { error: updateError } = await supabase
        .from('search_strings')
        .update({ 
          status: 'processing',
          updated_at: new Date().toISOString()
        })
        .eq('id', searchString.id);
      
      if (updateError) {
        console.error('Error updating search string status:', updateError);
        throw updateError;
      }
      
      try {
        await supabase.functions
          .invoke('generate-search-string', { 
            body: { 
              search_string_id: searchString.id,
              type,
              input_text: inputText,
              input_url: inputUrl,
              input_source: inputSource,
              user_id: user?.id
            }
          });
      } catch (functionErr) {
        console.error('Error calling generate-search-string function:', functionErr);
        
        const generatedString = await generatePreview(type, inputSource, inputText, inputUrl, pdfFile);
        
        await supabase
          .from('search_strings')
          .update({ 
            generated_string: generatedString,
            status: 'completed',
            updated_at: new Date().toISOString()
          })
          .eq('id', searchString.id);
      }
    }
  };

  const createSearchString = async (
    type: SearchStringType,
    inputSource: SearchStringSource,
    inputText?: string,
    inputUrl?: string,
    pdfFile?: File | null
  ) => {
    try {
      if (!user) {
        throw new Error('User not authenticated');
      }

      if (!user.id) {
        console.error('Missing user ID in authenticated user', user);
        throw new Error('User ID is missing');
      }

      console.log('Creating search string with user ID:', user.id);
      
      // Use a NULL company_id for users without company associations
      // This is a better approach than using a default UUID which might conflict
      const { data: searchString, error: insertError } = await supabase
        .from('search_strings')
        .insert({
          user_id: user.id,
          company_id: user.company_id || null, 
          type,
          input_source: inputSource,
          input_text: inputSource === 'text' ? inputText : undefined,
          input_url: inputSource === 'website' ? inputUrl : undefined,
          status: 'new',
          is_processed: false
        })
        .select()
        .single();
      
      if (insertError) {
        console.error('Error inserting search string:', insertError);
        
        if (insertError.message.includes('row-level security') || 
            insertError.message.includes('new row violates row-level security policy')) {
          
          // Try an alternative approach without company_id
          const { data: altSearchString, error: altInsertError } = await supabase
            .from('search_strings')
            .insert({
              user_id: user.id,
              company_id: null, // Explicitly set to NULL
              type,
              input_source: inputSource,
              input_text: inputSource === 'text' ? inputText : undefined,
              input_url: inputSource === 'website' ? inputUrl : undefined,
              status: 'new',
              is_processed: false
            })
            .select()
            .single();
            
          if (altInsertError) {
            console.error('Error with alternative insert approach:', altInsertError);
            throw new Error('Permission denied: You do not have access to create search strings. Please contact support.');
          }
          
          console.log('Search string created using alternative approach:', altSearchString);
          
          await processSearchStringBySource(
            altSearchString,
            inputSource,
            type,
            inputText,
            inputUrl,
            pdfFile
          );
          
          await fetchSearchStrings();
          
          return true;
        }
        
        throw insertError;
      }
      
      console.log('Search string created:', searchString);
      
      await processSearchStringBySource(
        searchString,
        inputSource,
        type,
        inputText,
        inputUrl,
        pdfFile
      );
      
      await fetchSearchStrings();
      
      return true;
    } catch (error: any) {
      console.error('Error creating search string:', error);
      throw error;
    }
  };

  const deleteSearchString = async (id: string) => {
    try {
      const { error } = await supabase
        .from('search_strings')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
      
      toast({
        title: 'Search string deleted',
        description: 'The search string has been successfully deleted',
      });
      
      await fetchSearchStrings();
      return true;
    } catch (error) {
      console.error('Error deleting search string:', error);
      toast({
        title: 'Failed to delete search string',
        description: 'Please try again later',
        variant: 'destructive',
      });
      return false;
    }
  };

  const updateSearchString = async (id: string, generatedString: string) => {
    try {
      const { error } = await supabase
        .from('search_strings')
        .update({ 
          generated_string: generatedString,
          updated_at: new Date().toISOString()
        })
        .eq('id', id);
      
      if (error) throw error;
      
      toast({
        title: 'Search string updated',
        description: 'The search string has been successfully updated',
      });
      
      await fetchSearchStrings();
      return true;
    } catch (error) {
      console.error('Error updating search string:', error);
      toast({
        title: 'Failed to update search string',
        description: 'Please try again later',
        variant: 'destructive',
      });
      return false;
    }
  };

  const markAsProcessed = async (id: string) => {
    try {
      if (!user) {
        throw new Error('User not authenticated');
      }
      
      const { error } = await supabase
        .from('search_strings')
        .update({ 
          is_processed: true, 
          processed_at: new Date().toISOString(),
          processed_by: user.id
        })
        .eq('id', id);
      
      if (error) throw error;
      
      toast({
        title: 'Search string marked as processed',
        description: 'The search string has been marked as processed',
      });
      
      await fetchSearchStrings();
      return true;
    } catch (error) {
      console.error('Error marking search string as processed:', error);
      toast({
        title: 'Failed to update search string',
        description: 'Please try again later',
        variant: 'destructive',
      });
      return false;
    }
  };

  const toggleSearchStringFeature = async (companyId: string, enable: boolean) => {
    try {
      const { error } = await supabase
        .from('companies')
        .update({ enable_search_strings: enable })
        .eq('id', companyId);
      
      if (error) throw error;
      
      toast({
        title: enable ? 'Feature enabled' : 'Feature disabled',
        description: `Search string feature has been ${enable ? 'enabled' : 'disabled'} for this company`,
      });
      
      return true;
    } catch (error) {
      console.error('Error toggling search string feature:', error);
      toast({
        title: 'Failed to update company settings',
        description: 'Please try again later',
        variant: 'destructive',
      });
      return false;
    }
  };

  return {
    createSearchString,
    deleteSearchString,
    updateSearchString,
    markAsProcessed,
    toggleSearchStringFeature,
    generatePreview,
  };
};
